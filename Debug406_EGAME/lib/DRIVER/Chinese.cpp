#include <TFT_eSPI.h> // ST7735 or ST7735S驱动
#include <SPI.h>
#include <tft_driver.h>
#include "Chinese.h"

#include <pgmspace.h>

PROGMEM const unsigned char hz16_20[] =//模
{
    0x11, 0x10, 
    0x11, 0x10, 
    0x17, 0xfc, 
    0x11, 0x10, 
    0xfc, 0x00, 
    0x13, 0xf8, 
    0x32, 0x08, 
    0x3b, 0xf8, 
    0x56, 0x08, 
    0x53, 0xf8, 
    0x90, 0x40, 
    0x17, 0xfc, 
    0x10, 0xa0, 
    0x11, 0x10, 
    0x12, 0x08, 
    0x14, 0x06
};

PROGMEM const unsigned char hz16_21[] =//式
{
    0x00, 0x48, 
    0x00, 0x44, 
    0x00, 0x44, 
    0x00, 0x40, 
    0xff, 0xfe, 
    0x00, 0x40, 
    0x00, 0x40, 
    0x3e, 0x40, 
    0x08, 0x40, 
    0x08, 0x40, 
    0x08, 0x20, 
    0x08, 0x22, 
    0x0f, 0x12, 
    0x78, 0x0a, 
    0x20, 0x06, 
    0x00, 0x02
};
PROGMEM const unsigned char hz16_22[] =//选
{
    0x00, 0x40, 
    0x22, 0x40, 
    0x12, 0x40, 
    0x13, 0xf8, 
    0x04, 0x40, 
    0x00, 0x40, 
    0xf7, 0xfc, 
    0x11, 0x20, 
    0x11, 0x20, 
    0x11, 0x20, 
    0x12, 0x24, 
    0x12, 0x24, 
    0x14, 0x1c, 
    0x28, 0x00, 
    0x47, 0xfe, 
    0x00, 0x00
};
PROGMEM const unsigned char hz16_23[] =//择
{
    0x20, 0x00, 
    0x27, 0xf8, 
    0x22, 0x08, 
    0x21, 0x10, 
    0xf0, 0xa0, 
    0x20, 0x40, 
    0x21, 0xb0, 
    0x26, 0x4e, 
    0x30, 0x40, 
    0xe3, 0xf8, 
    0x20, 0x40, 
    0x20, 0x40, 
    0x27, 0xfc, 
    0x20, 0x40, 
    0xa0, 0x40, 
    0x40, 0x40
};
PROGMEM const unsigned char hz16_24[] =//棋
{
    0x11, 0x08, 
    0x11, 0x08, 
    0x13, 0xfc, 
    0x11, 0x08, 
    0xfd, 0x08, 
    0x11, 0xf8, 
    0x31, 0x08, 
    0x39, 0x08, 
    0x55, 0xf8, 
    0x51, 0x08, 
    0x91, 0x08, 
    0x17, 0xfe, 
    0x10, 0x00, 
    0x10, 0x90, 
    0x11, 0x08, 
    0x12, 0x04
};
PROGMEM const unsigned char hz16_25[] =//子
{
    0x00, 0x00, 
    0x7f, 0xf8, 
    0x00, 0x10, 
    0x00, 0x20, 
    0x00, 0x40, 
    0x01, 0x80, 
    0x01, 0x00, 
    0xff, 0xfe, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x05, 0x00, 
    0x02, 0x00
};

PROGMEM const unsigned char hz16_26[] =//位
{
    0x08, 0x80, 
    0x08, 0x40, 
    0x08, 0x40, 
    0x10, 0x00, 
    0x17, 0xfc, 
    0x30, 0x00, 
    0x30, 0x08, 
    0x52, 0x08, 
    0x92, 0x08, 
    0x11, 0x10, 
    0x11, 0x10, 
    0x11, 0x10, 
    0x11, 0x20, 
    0x10, 0x20, 
    0x1f, 0xfe, 
    0x10, 0x00
};

PROGMEM const unsigned char hz16_27[] =//置
{
    0x7f, 0xfc, 
    0x44, 0x44, 
    0x7f, 0xfc, 
    0x01, 0x00, 
    0x7f, 0xfc, 
    0x01, 0x00, 
    0x1f, 0xf0, 
    0x10, 0x10, 
    0x1f, 0xf0, 
    0x10, 0x10, 
    0x1f, 0xf0, 
    0x10, 0x10, 
    0x1f, 0xf0, 
    0x10, 0x10, 
    0xff, 0xfe, 
    0x00, 0x00
};

PROGMEM const unsigned char hz16_28[] =//步
{
    0x01, 0x00, 
    0x01, 0x00, 
    0x11, 0xf8, 
    0x11, 0x00, 
    0x11, 0x00, 
    0x11, 0x00, 
    0xff, 0xfe, 
    0x01, 0x00, 
    0x01, 0x00, 
    0x11, 0x08, 
    0x11, 0x10, 
    0x21, 0x20, 
    0x40, 0xc0, 
    0x03, 0x00, 
    0x1c, 0x00, 
    0xe0, 0x00
};

PROGMEM const unsigned char hz16_29[] =//骤
{
    0x07, 0xe0, 
    0xf2, 0x5c, 
    0x13, 0xc4, 
    0x52, 0x54, 
    0x53, 0xc8, 
    0x52, 0x68, 
    0x57, 0xd4, 
    0x78, 0x64, 
    0x08, 0x3c, 
    0x0f, 0xc0, 
    0x39, 0x44, 
    0xca, 0x68, 
    0x08, 0xd0, 
    0x09, 0x48, 
    0x2e, 0x46, 
    0x10, 0x40
};

PROGMEM const unsigned char hz16_30[] =//最
{
    0x1f, 0xf0, 
    0x10, 0x10, 
    0x1f, 0xf0, 
    0x10, 0x10, 
    0x1f, 0xf0, 
    0x00, 0x00, 
    0xff, 0xfe, 
    0x22, 0x00, 
    0x3e, 0xf8, 
    0x22, 0x88, 
    0x3e, 0x90, 
    0x22, 0x50, 
    0x2f, 0x20, 
    0xf2, 0x50, 
    0x42, 0x88, 
    0x03, 0x06
};

PROGMEM const unsigned char hz16_31[] =//佳
{
    0x08, 0x40, 
    0x08, 0x40, 
    0x0b, 0xfc, 
    0x10, 0x40, 
    0x10, 0x40, 
    0x30, 0x40, 
    0x3f, 0xfe, 
    0x50, 0x00, 
    0x90, 0x40, 
    0x10, 0x40, 
    0x13, 0xfc, 
    0x10, 0x40, 
    0x10, 0x40, 
    0x10, 0x40, 
    0x1f, 0xfe, 
    0x10, 0x00
};

PROGMEM const unsigned char hz16_32[] =//盘
{
    0x02, 0x00, 
    0x04, 0x00, 
    0x1f, 0xf0, 
    0x11, 0x10, 
    0x10, 0x90, 
    0xff, 0xfe, 
    0x10, 0x10, 
    0x12, 0x10, 
    0x21, 0x50, 
    0x40, 0x20, 
    0x3f, 0xf8, 
    0x24, 0x48, 
    0x24, 0x48, 
    0x24, 0x48, 
    0xff, 0xfe, 
    0x00, 0x00
};

struct  FNT_HZ16                 // 汉字字模数据结构
{
  char  Index[4];               // 汉字内码索引,存放内码,如"中",在UTF-8编码下，每个汉字占3个字节，第四个是结束符0
  const unsigned char* hz16_Id;                        // 点阵码数据       存放内码后对应的 点阵序列  每个字需要32个字节的点阵序列
  unsigned char hz_width;
};

PROGMEM const FNT_HZ16 hanzi16[] =
{
  {"模", hz16_20,16}, {"式", hz16_21,16}, 
  {"选", hz16_22,16}, {"择", hz16_23,16}, 
  {"棋", hz16_24,16},{"子", hz16_25,16},
  {"位", hz16_26,16},{"置", hz16_27,16},
  {"步", hz16_28,16},{"骤", hz16_29,16},
  {"最", hz16_30,16},{"佳", hz16_31,16},
  {"盘", hz16_32,16},
};


void draw_Chinese(int32_t x, int32_t y, const char c[3], uint32_t color) 
{  //显示单一汉字
  for (int k = 0; k < 15; k++)
    if (hanzi16[k].Index[0] == c[0] && hanzi16[k].Index[1] == c[1] && hanzi16[k].Index[2] == c[2])
    { tft.drawBitmap(x, y, hanzi16[k].hz16_Id, hanzi16[k].hz_width, 16, color);
    }
}